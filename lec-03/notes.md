# Лекция 3. ООП на Python 3

## В прошлый раз ...

Здравствуйте!

В начале прошлого занятия мы размышляли о названии нашего курса.
Программирование на языке высокого уровня.

Мы говорили о том, что есть языки программирования низкого, среднего и
высокого уровней. Уровень языка соответствует уровню абстракций,
которыми приходится оперировать во время программирования.

Например, если при написании программы нам нужно выражать действия с
отдельными регистрами процессора или заботиться о правильном порядке
укладывания в стек программы аргументов подпрограммы перед вызовом
этой подпрограммы, то речь идет о низкоуровневом программировании.

Если же мы, например, работая с абстракцией "строка", должны
учитывать, что строка - это непрерывный фрагмент памяти, последний
байт которого имеет нулевое значение, при том, что у нас в
распоряжении имеется набор функций для работы со строками, то это
похоже на программирование на "среднем" уровне абстракции.

Попробуйте найти больше примеров.

Но нас интересует программирование на высоком уровне абстракции. В
каком смысле? И почему магистрантам вашего направления это должно быть
полезно?

Предполагается, что в магистратуре вы занимаетесь научной работой. К
тому же, направление вашей магистратуры - это прикладная
информатика. Т.е. вам нужно применить информационные технологии для
(частичного) решения какой-то проблемы, получив в результате
общественно новое знание (научная новизна).

Часть мира, для которой решается задача, называется предметной
областью. Работа в предметной области обычно подразумевает
абстрагирование - рассмотрение части мира с точки зрения задачи,
выделение важного и отбрасывание второстепенного. В результате вы
получаете набор абстракций.

А потом вам нужно установить соответствие между этими абстракциями и
абстракциями языка программирования. Выбирая язык высокого уровня мы
сокращаем расстояние между этими абстракциями.

Это не значит, впрочем, что понятия предметной области всегда прямо
отображаются в компоненты программы. Иногда удачное проектное решение
состоит в использовании понятий, не соответствующих напрямую чему-либо
в предметной области (см. паттерны проектирования).

Но можно посмотреть на наш курс проще. На этом направлении
магистратуры оказываются люди очень разных специальностей. И для
кого-то важно просто немного научиться программировать. Т.е. нужен
язык программирования с небольшим порогом вхождения (т.е. позволяющий
быстро начать писать первые программы) и способный помочь в работе над
магистерской диссертацией, например, когда надо будет что-то
посчитать.

Таким языком является Python 3.

На прошлом занятии мы очень бегло познакомились с этим языком. Мы
говорили о том, что Python - интерпретируемый язык. Говорили о
динамической сильной типизации. Рассматривали простые и сложные
встроенные типы данных. Под сложными типами я подразумеваю списки,
кортежи и словари. Мы познакомились с такой единицей программы, как
**функция**.

Сегодня мы будем говорить о классах и объектах.

## Как быть

Но сначала я должен показать, как запускать примеры и вообще работать
с этими материалами.

Скорее всего, в адресной строке вашего браузера сейчас есть такое:
https://github.com/aleneus/pvo и так далее. Когда началась вся эта
история с дистанционной работой, я долго думал, как нам
быть. Университет предоставил нам место на Sakai. Но я подумал, что
когда мы изучаем программирование, нам было бы полезно поработать с
системами управления программистскими проектами и с системами контроля
версий. Почему бы не воспользоваться случаем? К тому же, это очень
удобно. Я создал открытый проект на github.

Вы вполне можете прислать мне **pull-request** (почитайте о том, что
это такое, о том, как работает сообщество программистов) с
исправлением какой-то части лекции или даже практической работы. Или
дополнением.

Итак, вы находитесь в *репозитории* github.com/aleneus/pvo. Можно
считать, что это просто папка с файлами, которая где-то расположена. В
этой папке есть другие папки. Из их названий понятно, где находятся
материалы лекций, а где - практические задания. Осмотритесь. Правда,
сегодня, скорее всего вы увидите только папку с лекцией. Я в процессе.

Еще вы можете видеть всю историю работы над этими заметками, примерами
и заданиями. Обратите внимание на раздел **commits**.

Вы можете скопировать весь проект к себе на компьютер в виде
архива. Или вы можете установить **git** и выполнить
**клонирование**. Это будет более профессионально. Мы можем потом
подробней поговорить об этих вещах. Дайте мне знать (можете, например,
позвонить), если вы хотите сделать это как можно раньше. Я подготовлю
материал.

Рядом с этими заметками лежит текстовый файл **example.py**. Допустим,
что вы скачали на свой компьютер папку **lec-03**. Допустим, что вы
установили Python 3 на свой компьютер.

Откройте командную строку (cmd), зайдите в папку **lec-03** (команда
cd) и дайте команду:

```
py example.py
```

## Определение класса

Итак, поехали. Возьмем какой-нибудь "игрушечный" пример. Представим
себе больницу. Там есть врачи и пациенты. Врачи лечат пациентов. Вот и
все абстрагирование.

Для начала, укажем на тот факт, что для понятий "врач" и "пациент"
есть обобщающее понятие "персона".

Рассмотрим фрагмент кода (весь код см. в **exmaple.py**):

```
MALE   = True
FEMALE = False

class Person:
	"""Person represents the person."""
	def __init__(self, sex, name=None):
		self.set_sex(sex)
		self.name = name

	def set_sex(self, sex):
		"""Sets the sex of person."""
		if sex not in [MALE, FEMALE]:
			raise ValueError("Unknown sex")

		self._sex = sex

	def get_sex(self):
		"""Returns sex."""
		return self._sex

	sex = property(get_sex, set_sex, "Sex of person.")
```

Будем разбирать его фрагменты.

Здесь

```
MALE   = 0
FEMALE = 1
```

я создаю две переменные. Одна обозначает понятие "мужчина", а другая -
"женщина". Значения этих переменных - это коды указанных понятий. 0 -
мужчина, 1 - женщина. Договоримся, что мы нигде не имеем права менять
значения этих переменных, кроме этого самого места, где переменные
возникли. Будем считать, что это не переменные, а константы. Хотя, это
переменные.

`class Person:` - это заголовок класса. Напомним, что класс - это
множество объектов с одинаковым **набором** атрибутов. Этой
конструкцией мы утверждаем, что у нас есть мужество людей.

В следующих строка - отступы в 4 пробела и больше. Пока есть отступы
относительно слова class, мы находимся в определении класса. Как
только отступ исчезает, определение класса заканчивается.

`"""Person represents the person."""` - это строка документации. Она
описывает класс.

Здесь `def __init__(self, sex, name=None)` мы говорим, что у объектов
нашего класса есть функция (еще говорят "метод") `__init__`. По
правилам языка функция с таким именем вызывается как только создается
объект. Первый аргумент - `self` - это и есть созданный объект, ссылка
на него. Функция имеет еще два аргумента: `sex` и `name`, пол и
имя. При этом имя задавать необязательно, поскольку сказано, что его
значение по умолчанию - `None`, т.е. ничто. Появляется человек - пол у
него есть, а имени еще нет. Нормально.

Здесь `self.set_sex(sex)` для объекта класса "персона" вызывается
метод `set_sex` этого же класса. Вот этот метод:

```
	def set_sex(self, sex):
		"""Sets the sex of person."""
		if sex not in [MALE, FEMALE]:
			raise ValueError("Unknown sex")

		self._sex = sex
```

Здесь выполняется проверка того, что пол должен быть равен одной из
заданных выше констант, т.е. должен быть или мужским, или
женским. Если это не так, то вызывается **исключение**, приводящее к
возникновению ошибки при работе программы. После успешного прохождения
проверки к объекту добавляется поле `_sex`, а его значением становится
указанный пол.

Здесь `self.name = name` создается и получает свое значение поле
`name`.

Метод

```
	def get_sex(self):
		"""Returns sex."""
		return self._sex
```

просто возвращает значение поля `_sex`.

Фрагмент `sex = property(get_sex, set_sex, "Sex of person.")` делает
так, чтобы обращение к "полю" `sex` (не `_sex`!) для чтения вызывало
бы метод `get_sex`, а обращение для записи - `set_sex`. Это свойство,
`sex` без подчеркивания - свойство. Выглядит как поле, а скрывает за
собой два метода - setter и getter. `"Sex of person."` - это строка
документации для свойства.

Чтобы посмотреть как работает все, что мы пока сделали напишем такую
функцию:

```
def ex_fields():
	"""Fields of person"""
	p = Person(FEMALE, "Anna")
	print(p.sex)
	print(p.name)
```

Она не в классе, а сама по себе. В ней создается объект класса
"персона" и выводятся пол и имя этой персоны.

Для запуска примеров я написал вспомогательную функцию:

```
def run(func):
	"""Run example decorator."""
	print("Example: {}".format(func.__doc__))
	func()
	print()
```

Аргументом является функция, которую надо запустить. Перед запуском
выводится строка доментации той функции, которую надо запустить. Потом
запускается функция. Потом выводится пустая строка, чтобы лучше было
видно, что этот пример закончился. Это называется "декоратор".

Результат выполнения первого примера такой:
```
Example: Fields of person
True
Anna
```

## __repr__()

Так себе результат. Что значит `True`? При чем тут пол? Давайте
улучшим представление объекта - его "representation".

Добавим в класс ``Person``` еще три метода:

```
	def __repr__(self):
		name = self.__repr_name()
		sex = self.__repr_sex()
		return "{} ({})".format(name, sex)

	def __repr_name(self):
		if not self.name:
			return "Somebody"
		return self.name

	def __repr_sex(self):
		return "M" if self.sex == MALE else "F"
```

и добавим пример:

```
def ex_two_persons():
	"""Effect of __repr__ method"""
	p1 = Person(MALE, "Ivan")
	print(p1)
```

Результат его выполнения:

```
Example: Effect of __repr__ method
Ivan (M)
```

В чем тут фокус? Дело в том, что функция `print(объект)` на самом деле
вызывает метод `__repr__` объекта, который указан в качестве аргумента
и печатает строку, которую возвращает этот метод.

Вот здесь `return "{} ({})".format(name, sex)` мы конструируем эту
строку. Круглые скобки обозначают место, в которое надо что-то
подставить. А то, что надо подставить, перечисляется в аргументах
функции `format`.

Эта функция является методом класса `str`. Когда мы пишем какой-то
текст в кавычках, то на самом деле мы создаем в этом месте объект
класса строка и можем вызывать его методы через точку, например:
`"{}+{}={}".format(1, 2, 3)`.

Подумайте сами о вспомогательных методах `__repr_name(self)` и
`__repr_sex(self)`. Я укажу только на то, что их имена начинаются с
двух знаков подчеркивания. В Python это означает, что методы являются
скрытыми, не предназначенными для вызова извне.

## Наследование

Ниже представлен код классов `Doctor` и `Patient`:

```
class Doctor(Person):
	"""Doctor represents the doctor."""
	def __init__(self, sex, name):
		super().__init__(sex, name)
		self._spec = None

	def set_spec(self, spec):
		"""Sets speciality."""
		self._spec = spec

	def get_spec(self):
		"""Returns the speciality."""
		return self._spec

	spec = property(get_spec, set_spec, "Speciality")


class Patient(Person):
	"""Patient represents the patient."""
	def __init__(self, sex, name=None, health=100):
		super().__init__(sex, name)
		self._health = health

	def get_health(self):
		"""Returns health value."""
		return self._health

	def set_healph(self, value):
		"""Sets health value for the patient."""
		if value > 100:
			self._health = 100
		else:
			self._health = value

	health = property(get_health, set_healph, "Health value")
```

Чтобы показать, что некоторый класс является наследником другого
(родительского) класса, надо родительский класс указать в скобках,
после имени определяемого класса, например: `Patient(Person)`.

В методах `__init__` вы видите конструкцию:
`super().__init__(...)`. Это вызов метода `__init__` родительского
класса (суперкласса). Таким образом мы можем сначала выполнить
конструктор родительского класса, а потом выполнить еще какие-то
действия в дочернем классе.

Еще прошу обратить внимание на метод `set_healph` у пациента. Он
реализован так, чтобы уровень "здоровья" не был больше 100
(процентов). Как в компьютерных играх.

Пара примеров:

```
def ex_inheritance():
	"""Doctor and patient are persons"""
	d = Doctor(MALE, "Alex")
	print(d)
	p = Patient(FEMALE, "Nina")
	print(p)


def ex_property():
	"""Property"""
	d = Doctor(MALE, "Peter")
	d.spec = "Surgeon"
	print(d.spec)
```

Результат:

```
Example: Doctor and patient are persons
Alex (M)
Nina (F)

Example: Property
Surgeon
```

**ВАЖНО!** Все классы являются наследниками класса `Object`. На этом
верхнем уровне определены некоторые специальные методы: `__init__`,
`__repr__` и другие. Таким образом мы можем быть уверены, что эти
методы есть у любого класса, даже если мы ничего для этого специально
не делали.

## Метод __call__()

Интересным методом является `__call__`. Посмотрим на класс "лечение":

```
class Treatment:
	"""Treatment represents the act of treatment."""
	def __init__(self, strength=1):
		self.strength = strength

	def __call__(self, patient):
		patient.health = patient.health + self.strength
```

и пример его использования:

```
def ex_callable():
	"""Callable object"""
	p = Patient(MALE, "Sergey", health=30)
	t = Treatment(strength=26)

	for i in range(4):
		t(p)
		print(p.health)
```

Вывод:

```
Example: Callable object
56
82
100
100
```

Здесь `t = Treatment(strength=26)` на самом деле вызывается метод
`__init__` класса "лечение". Конструктору передается значение "силы"
лечения. Т.е. мы создаем настроенный определенным образом объект. В
данном случае создается "лечение" определенной "силы". Я писал, что
это игрушечный пример. Не думайте об этом слишком сложно.

А здесь `t(p)` на самом деле вызывается метод `__call__`. Объекты, у
которых определен метод `__call__`, называются callable-объектами.

Лечение применяется к пациенту. После этого здоровье пациента
увеличивается в зависимости от силы лечения.

## Функции

На самом деле функции в Python - это объекты с методом
`__call__`. Посмотрите внимательно на реализацию моей функции `run` -
вы увидите, что я воспользовался этим знанием.


На сегодня хватит. Всего доброго!
