# Лекция 3. ООП на Python 3

## В прошлый раз ...

Здравствуйте!

В начале прошлого занятия мы размышляли о названии нашего курса.
Программирование на языке высокого уровня.

Мы говорили о том, что есть языки программирования низкого, среднего и
высокого уровней. Уровень языка соответствует уровню абстракций,
которыми приходится оперировать во время программирования.

Например, если при написании программы нам нужно выражать действия с
отдельными регистрами процессора или заботиться о правильном порядке
укладывания в стек программы аргументов подпрограммы перед вызовом
этой подпрограммы, то речь идет о низкоуровневом программировании.

Если же мы, например, работая с абстракцией "строка", должны
учитывать, что строка - это непрерывный фрагмент памяти, последний
байт которого имеет нулевое значение, при том, что у нас в
распоряжении имеется набор функций для работы со строками, то это
похоже на программировании на "среднем" уровне абстракции.

Попробуйте найти больше примеров.

Но нас интересует программирование на высоком уровне абстракции. В
каком смысле? И почему магистрантам вашего направления это должно быть
полезно?

Предполагается, что в магистратуре вы занимаетесь научной работой. К
тому же, направление вашей магистратуры - это прикладная
информатика. Т.е. вам нужно применить информационные технологии для
(частичного) решения какой-то проблемы, получив в результате
общественно новое знание (научная новизна).

Часть мира, для которой решается задача, называется предметной
областью. Работа в предметной области обычно подразумевает
абстрагирование - рассмотрение части мира с точки зрения задачи,
выделение важного и отбрасывание второстепенного. В результате вы
получаете набор абстракций.

А потом вам нужно установить соответствие между этими абстракциями и
абстракциями языка программирования. Выбирая язык высокого уровня мы
сокращаем расстояние между этими абстракциями.

Это не значит, впрочем, что понятия предметной области всегда прямо
отображаются в компоненты программы. Иногда удачное проектное решение
состоит в использовании понятий, не соответствующих напрямую чему-либо
в предметной области (см. паттерны проектирования).

Но можно посмотреть на наш курс проще. На этом направлении
магистратуры оказываются люди очень разных специальностей. И для
кого-то важно просто немного научиться программировать. Т.е. нужен
язык программирования с небольшим порогом вхождения (т.е. позволяющий
быстро начать писать первые программы) и способный помочь в работе над
магистерской диссертацией, например, когда надо будет что-то
посчитать.

Таким языком является Python 3.

На прошлом занятии мы очень бегло познакомились с этим языком. Мы
говорили о том, что Python - интерпретируемый язык. Говорили о
динамической сильной типизации. Рассматривали простые и сложные
встроенные типы данных. Под сложными типами я подразумеваю списки,
кортежи и словари. Мы познакомились с такой единицей программы, как
**функция**.

Сегодня мы будем говорить о классах и объектах.

## Как быть

Но сначала я должен показать, как запускать примеры и вообще работать
с этими материалами.

Скорее всего, в адресной строке вашего браузера сейчас есть такое:
https://github.com/aleneus/pvo и так далее. Когда началась вся эта
история с дистанционной работой, я долго думал, как нам
быть. Университет предоставил нам место на Sakai. Но я подумал, что
когда мы изучаем программирование, нам было бы полезно поработать с
системами управления программистскими проектами и с системами контроля
версий. Почему бы не воспользоваться случаем? К тому же, это очень
удобно. Я создал открытый проект на github.

Вы вполне можете прислать мне **pull-request** (почитайте о том, что
это такое, о том, как работает сообщество программистов) с
исправлением какой-то части лекции или даже практической работы. Или
дополнением.

Итак, вы находитесь в *репозитории* github.com/aleneus/pvo. Можно
считать, что это просто папка с файлами, которая где-то расположена. В
этой папке есть другие папки. Из их названий понятно, где находятся
материалы лекций, а где - практические задания. Осмотритесь. Правда,
сегодня, скорее всего вы увидите только папку с лекцией. Я в процессе.

Еще вы можете видеть всю историю работы над этими заметками, примерами
и заданиями. Обратите внимание на раздел **commits**.

Вы можете скопировать весь проект к себе на компьютер в виде
архива. Или вы можете установить **git** и выполнить
**клонирование**. Это будет более профессионально. Мы можем потом
подробней поговорить об этих вещах. Дайте мне знать (можете, например,
позвонить), если вы хотите сделать это как можно раньше. Я подготовлю
материал.

Рядом с этими заметками лежит текстовый файл **example.py**. Допустим,
что вы скачали на свой компьютер папку **lec-03**. Допустим, что вы
установили Python 3 на свой компьютер.

Откройте командную строку (cmd), зайдите в папку **lec-03** (команда
cd) и дайте команду:

```
py example.py
```

## Определение класса

Итак, поехали. Возьмем какой-нибудь "игрушечный" пример. Представим
себе больницу. Там есть врачи и пациенты. Врачи лечат пациентов. Вот и
все абстрагирование.

Для начала, укажем на тот факт, что для понятий "врач" и "пациент"
есть обобщающее понятие "персона".

Рассмотрим фрагмент кода (весь код см. в **exmaple.py**):

```
MALE   = True
FEMALE = False

class Person:
	"""Person represents the person."""
	def __init__(self, sex, name=None):
		self.set_sex(sex)
		self.name = name

	def set_sex(self, sex):
		"""Sets the sex of person."""
		if sex not in [MALE, FEMALE]:
			raise ValueError("Unknown sex")

		self._sex = sex

	def get_sex(self):
		"""Returns sex."""
		return self._sex

	sex = property(get_sex, set_sex, "Sex of person.")
```

Будем разбирать его фрагменты.

Здесь

```
MALE   = 0
FEMALE = 1
```

я создаю две переменные. Одна обозначает понятие "мужчина", а другая -
"женщина". Значения этих переменных - это коды указанных понятий. 0 -
мужчина, 1 - женщина. Договоримся, что мы нигде не имеем права менять
значения этих переменных, кроме этого самого места, где переменные
возникли. Будем считать, что это не переменные, а константы. Хотя, это
переменные.

`class Person:` - это заголовок класса. Напомним, что класс - это
множество объектов с одинаковым **набором** атрибутов. Этой
конструкцией мы утверждаем, что у нас есть мужество людей.

В следующих строка - отступы в 4 пробела и больше. Пока есть отступы
относительно слова class, мы находимся в определении класса. Как
только отступ исчезает, определение класса заканчивается.

`"""Person represents the person."""` - это строка документации. Она
описывает класс.

Здесь `def __init__(self, sex, name=None)` мы говорим, что у объектов
нашего класса есть функция (еще говорят "метод") `__init__`. По
правилам языка функция с таким именем вызывается как только создается
объект. Первый аргумент - `self` - это и есть созданный объект, ссылка
на него. Функция имеет еще два аргумента: `sex` и `name`, пол и
имя. При этом имя задавать необязательно, поскольку сказано, что его
значение по умолчанию - `None`, т.е. ничто. Появляется человек - пол у
него есть, а имени еще нет. Нормально.

Здесь `self.set_sex(sex)` для объекта класса "персона" вызывается
метод `set_sex` этого же класса. Вот этот метод:

```
	def set_sex(self, sex):
		"""Sets the sex of person."""
		if sex not in [MALE, FEMALE]:
			raise ValueError("Unknown sex")

		self._sex = sex
```

Здесь выполняется проверка того, что пол должен быть равен одной из
заданных выше констант, т.е. должен быть или мужским, или
женским. Если это не так, то вызывается **исключение**, приводящее к
возникновению ошибки при работе программы. После успешного прохождения
проверки к объекту добавляется поле `_sex`, а его значением становится
указанный пол.

Здесь `self.name = name` создается и получает свое значение поле
`name`.

Метод

```
	def get_sex(self):
		"""Returns sex."""
		return self._sex
```

просто возвращает значение поля `_sex`.

Фра мент `sex = property(get_sex, set_sex, "Sex of person.")` делает
так, чтобы обращение к "полю" `sex` (не `_sex`!) для чтения вызывало
бы метод `get_sex`, а обращение для записи - `set_sex`. Это свойство,
`sex` без подчеркивания - свойство. Выглядит как поле, а скрывает за
собой два метода - setter и getter. `"Sex of person."` - это строка
документации для свойства.

Чтобы посмотреть как работает все, что мы пока сделали напишем такую
функцию:

```
def ex_fields():
	"""Fields of person"""
	p = Person(FEMALE, "Anna")
	print(p.sex)
	print(p.name)
```

Она не в классе, а сама по себе. В ней создается объект класса
"персона" и выводятся пол и имя этой персоны.

Для запуска примеров я написал вспомогательную функцию:

```
def run(func):
	"""Run example decorator."""
	print("Example: {}".format(func.__doc__))
	func()
	print()
```

Аргументом является функция, которую надо запустить. Перед запуском
выводится строка доментации той функции, которую надо запустить. Потом
запускается функция. Потом выводится пустая строка, чтобы лучше было
видно, что этот пример закончился. Это называется "декоратор".

Результат выполнения первого примера такой:
```
Example: Fields of person
True
Anna
```

## __repr__()

Так себе результат. Что значит `true`? При чем тут пол? Давайте
улучшим представление объекта - его "representation".

## Наследование

## __call__()

## Всё - объект

## Домашнее задание

**TODO**: отношение "врач лечит пациента"

## Ссылки

[Python](http://python.org)
